## Transaction

### 트랜잭션(Transaction)이란 무엇인가?

트랜잭션은 작업의 완전성을 보장해주는 것이다. 즉, 논리적인 작업들이 모두 완벽하게 처리된다면 상관이 없지만, 완벽하게 처리하지 못할 경우 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어준다. 각각의 입장에서는 트랜잭션은 다음과 같이 정의할 수 있다.

- 사용자 입장: 논리적인 작업 단위
- 시스템 입장: 데이터를 접근 또는 변경하는 프로그램의 단위

### 트랜잭션의 특징

트랜잭션은 반드시 다음 4가지 특성(ACID)을 만족해야 한다.

#### 원자성(Atomicity)

트랜잭션은 모두 성공하거나 모두 실패해야 한다. 즉, 트랜잭션 중간에 어떤 문제가 발생하여 한 작업에 문제가 생길경우 모두 원 상태로 복구해야 하고, 아니라면 모두 반영되어야 한다.

> 항공 티켓 주문을 원자성의 예시로 들 수 있다. 티켓은 반드시 지불과 동시에 좌석 예약이 되거나 아니면 모두 되지 않아야 할 것이다. 티켓 값만 지불하고 좌석 예약이 되지 않는 경우는 허용되지 않는다는 것이다.

#### 일관성(Consistency)

트랜잭션이 완료된 상태와 트랜잭션이 일어나기 전의 상태는 데이터의 일관성을 보장해야 한다. 즉, 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.

>  친구한테 계좌 송금을 하는 것을 예시로 들 수 있다. 송금을 하기 위해서는 계좌에 0원보다 많은 돈이 있어야한다. 만약 내 계좌에 돈이 1000원이 있는데 친구한테 1001원을 송금할 수 없을 것이다. 즉, 내 통장은 일관성을 지키기 때문에 송금이 불가능한 것이다. 송금하기 전의 통장은 0원이상이 필요하고 송금 후에도 0원이상 남아있어야 한다는 것을 의미한다.

#### 고립성(Isolation)

트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다.

> 만약 일하거나 공부를 하는 도중에 다른 사람이 말을 건다고 생각을 해보면 집중력을 잃어버릴 것이다. 이것은 데이터베이스도 마찬가지이다. 작업을 하는 도중에 다른 작업이 끼어든다면 성능이 안좋아질 것이다. 성능관련 이유로 인해 이 특성은 가장 유연성 있는 제약조건이라고 볼 수 있다.

#### 지속성(Durability)

성공적으로 수행된 트랜잭션은 영구적으로 데이터베이스에 작업 결과가 반영되어야 한다.

> 우리가 문서를 작성하고 저장한 다음 다시 문서를 키면 저장버튼을 누르고 껐기 때문에 데이터가 보존되어있다. 하지만 저장버튼을 누르지 않고 문서를 껐다 키면 데이터가 보존되어있지 않을 것이다.

## 트랜잭션 격리수준(Isolation Level)

### 트랜잭션 격리수준이란?
동시에 여러 트랜잭션들이 처리될 때, 서로 얼마나 고립되어 있는지를 나타내는 것이다. 즉, 특정 트랜잭션이 다른 트랜잭션이 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.

격리수준은 크게 아래의 4가지로 나뉜다.

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

아래로 갈수록 트랜잭션 고립 정도가 높아지며, 성능이 떨어지는 것이 일반적이다. 일반적인 온라인 서비스에서는 READ COMMITTED 나 REPEATABLE READ 중 하나를 사용한다. (Oracle: READ COMMITTED, MySQL: REPEATABLE READ)

### READ UNCOMMITTED

해당 격리수준에서는 어떤 트랜잭션이 데이터를 변경하고 오랫동안 커밋하지 않은 상태에서 다른 트랜잭션이 변경된 값을 볼 수 있다는 것이다. 이 격리수준에서는 다음과 같은 문제점이 발생할 수 있다.

1. A 트랜잭션이 특정 레코드를 변경하고 커밋하지 않음
2. 커밋하지 않은 상태에서 B 트랜잭션이 변경된 레코드를 조회함
3. A 트랜잭션이 변경내용을 롤백함
4. B 트랜잭션은 올바르지 않은 내용을 조회하게 된다.

이러한 데이터의 정합성 부분에 문제가 많아서 RDBMS 표준에서는 격리수준으로 인정하지도 않는다.

### READ COMMITTED

어떤 트랜잭션이 데이터의 변경을 수행하고나서 커밋을 해야만 다른 트랜잭션이 변경된 내용을 조회할 수 있는 격리수준이다. 즉, A 트랜잭션이 어떤 레코드를 변경하고 커밋을 하지 않는다면 A 트랜잭션에서는 변경내용이 조회가 되지만 B 트랜잭션에서는 변경내용이 조회되지 않고 변경 전의 내용이 조회된다는 것이다.

이렇게 보면 데이터의 정합성에 문제가 없을것 이라고 생각할 수 있지만, 여기에도 문제점이 있다. 다음의 예시를 보자

1. A 트랜잭션에서 회원의 나이를 조회한 결과로 20살을 얻음
2. B 트랜잭션에서 회원의 나이를 21살로 변경하고 커밋
3. A 트랜잭션에서 회원의 나이를 다시 조회한 결과로 21살을 얻음

이는 하나의 트랜잭션 내에서 똑같은 SELECT를 수행했을 경우 항상 같은 결과를 반환해야 한다는 REPEATABLE READ 정합성에 어긋나는 것이다.

### REPEATABLE READ

이 격리수준은 트랜잭션이 시작되기 전에 커밋된 내용들에 대해서만 조회할 수 있는 격리수준이다. MySQL에서는 이 격리수준을 기본적으로 사용하고 있고 이 격리수준에서는 NON-REPEATABLE READ 부정합이 발생하지 않는다. 즉, 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(커밋된) 것만 볼 수 있는 것이다. (모든 DB의 트랜잭션에는 고유한 트랜잭션 번호를 가지고 있다.)

### SERIALIZABLE

가장 단순하고 엄격한 격리수준이다. InnoDB에서는 기본적으로 순수한 SELECT 작업은 아무런 잠금을 걸지않고 동작하는데, 격리수준이 SERIALIZABLE일 경우 읽기 작업에도 공유 잠금을 설정하게 되고, 이러면 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못하게 된다. 이러한 특성때문에 동시처리 능력이 다른 격리수준보다 떨어지고, 성능저하가 발생하게 된다.

## 인덱스(Index)

### 인덱스(Index)란 무엇인가?

데이터베이스 분야에 있어서 테이블에 대한 동작속도를 높여주는 자료구조를 말한다. 인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다. 이런 말로 비추어 보아 인덱스는 책의 맨 처음 또는 맨 마지막에 있는 색인이라고 할 수 있다. 만약 데이터베이스에 들어있는 자료의 레코드(행)이 50인 데이터가 내가 찾고싶은 데이터라면, 책의 목차에 '50페이지 : 무엇무엇' 이라고 적혀있는 것이다. 

 이렇게 인덱스를 사용하면 좋은점이 무엇인지 보일것이다. 데이터베이스 테이블의 용량이 충분히 크다면 DBMS가 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래걸릴 것이다. 그래서 컬럼의 값과 원하는 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다.
 
  인덱스를 사용한다고 항상 성능이 잘나오는 것은 아니다. DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 데이터를 조회할 때는 인덱스를 사용하는 것이 성능이 잘나오지만, 데이터를 추가, 수정, 삭제하는 경우에는 쿼리문 실행 속도가 느려진다.
  
  따라서 인덱스를 사용하는 이유는 데이터의 조회 성능을 높이고, 다른 성능을 희생하는 것이 된다. 물론 인덱스를 사용해서 데이터를 조회한다고 모든 상황에서 다 성능이 잘나오는 것은 아니므로 상황에 맞게 사용하도록 하는게 좋다.
  
### 인덱스(Index)의 성능과 고려해야할 사항
  
  인덱스(Index)는 SELECT 쿼리의 성능을 향상시킨다고 앞서 설명하였다. 그런데 인덱스(Index)는 항상 좋을까? 앞서 말했듯이 항상 성능이 잘나오는 것은 아니다.
  
  첫번째 이유는 인덱스(Index)를 생성하게 되면 Insert, Delete, Update 쿼리문을 실행할 때 별도의 과정이 추가로 발생한다. Insert의 경우에도 Index에 관한 내용을 추가해야 하므로 성능의 손실이 있다. Delete의 경우에는 데이터를 삭제해도 Index의 내용은 삭제하지 않고 사용하지 않는다는 표시로 남게된다. 이말은 즉슨 실제 데이터는 10만인데 인덱스(Index)는 100만이라는 데이터가 있을 수 있다는 것이다. Update는 더 최악으로 치닫는다. 왜냐하면 Insert와 Delete를 둘 다 수행하기 때문이다.
  
  두번째 이유는 컬럼을 이루는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다는 것이다. **이름**, **나이**, **성별**  세 가지의 필드를 갖고있는 테이블을 생각해보자. 이름은 온갖 경우의 수가 존재할 것이며 나이는 정수형 타입을 가질 것이고, 성별은 남, 녀 두가지 경우에 대해서만 데이터가 존재할 것이다. 결론부터 말하면 이름만 인덱스를 생성해서 사용하는 것이 효율적이고 나머지는 비효율적이다.
  
  왜그럴까? 10000개의 행(레코드)를 가지는 테이블에 대해서 2000단위로 성별에 인덱스를 생성했다고 가정하자. 값의 범위가 적은 성별은 인덱스를 읽고 다시 한번 디스크 I/O가 발생하기 때문에 그만큼 비효율적인 것이다.

## 정규화

### 정규화란?
관계형 데이터베이스에서 데이터의 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 구체적으로는 중복이 존재하는 릴레이션의 애트리뷰트들을 나누어서 작은 릴레이션으로 분해하는 작업을 의미한다. 정규화 과정을 거치게 되면 정규형을 만족하게 되는데, 정규형이란 특정 조건을 만족하는 릴레이션의 스키마 형태를 말하며 제1 정규형, 제2 정규형 ... 등이 존재한다.

### 이상현상(Anomaly)

정규화를 데이터의 중복을 최소화하기 위한 작업이라고 하였는데, 이러한 중복은 이상현상(anomaly)에 의해서 발생한다. 이상현상이란 데이터들이 불필요하게 중복되어 테이블을 조작할 때 발생하는 데이터 불일치 현상이다. 이상현상은 세 가지 종류가 존재하는데 다음과 같다.

- 삽입 이상: 원하지 않는 자료가 삽입 되거나, 삽입하는데에 필요한 자료가 부족해서 삽입되지 않아서 발생하는 문제점

> ex) 애트리뷰트가 학번, 지도교수, 학과, 과목번호, 성적 인 학생 테이블이 있다고 가정해보자. 만약 강의를 수강하지 않은 학생을 이 테이블이 추가한다고 하면 과목번호와 성적이 null인 불필요한 정보도 같이 들어가야 하는 문제점이 발생한다. 또한, 학생이 수강신청을 할 때 반드시 과목번호를 알아야 삽입이 가능하다는 문제점도 존재한다.

- 삭제 이상: 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점

> ex) 애트리뷰트가 학번, 지도교수, 학과, 과목번호, 성적 인 학생 테이블이 있다고 가정해보자. 만약 교수 한명이 강의를 폐강한다면 해당 강의에 대한 내용이 없어질 뿐만아니라, 그 강의를 듣는 학생 레코드가 전체가 삭제된다는 문제점이 있다.

- 갱신 이상: 데이터의 일부만 변경하여 데이터의 불일치가 나타나게 되는 문제점, 또는 중복되는 튜플이 존재하게 되는 문제점

> ex) 애트리뷰트가 학번, 지도교수, 학과, 과목번호, 성적 인 학생 테이블이 있다고 가정해보자. 만약 학생이 여러개의 과목을 수강하고 있고, 이 때 지도교수가 변경된다면 그 학생에 대한 모든 레코드에서의 지도교수를 변경해주어야 한다는 문제점이 있다.
