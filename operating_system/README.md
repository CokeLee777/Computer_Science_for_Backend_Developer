## 프로세스와 스레드

### 프로세스(Process)란 무엇인가?

프로세스는 실행중인 프로그램을 뜻한다. 프로그램은 하드디스크 등의 저장공간에 저장되어 있는 코드와 리소스 등이 집합되어 있는 파일을 말하고, 실행하면 메모리에 적재되어 프로세스로 동작한다. 구체적으로 살펴보면 프로세스는 함수의 매개변수, 복귀 주소와 지역 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 저장하는 데이터 섹션을 포함한다. 또한 프로세스는 실행중에 동적으로 할당되는 메모리인 힙 영역도 포함한다.

#### 프로세스 제어 블록(Process Control Block, PCB)

PCB는 특정 프로세스에 관한 정보를 저장하고 있는 운영체제 커널의 자료구조이다. 프로세스는 생성과 동시에 자신의 고유한 PCB를 생성한다. 프로세스는 작업을 하다가 프로세스 전환이 발생하면 작업을 저장하고 CPU를 반환해야 하는데, 이 때 자신의 PCB에 작업에 관한 정보를 저장하게 된다. 그리고 다시 CPU를 할당받게 되면 PCB로 부터 작업 정보들을 가져와서 수행하게 된다.

PCB에 저장되는 정보는 다음과 같다.

- 프로세스 식별자(Process ID, PID): 프로세스 식별번호
- 프로세스 상태: 생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 완료(Terminated) 상태를 저장
- 프로그램 카운터(Program Counter, PC): 프로세스가 다음으로 실행할 명령어의 주소를 가리킨다.
- CPU 레지스터
- CPU 스케줄링 정보: 프로세스의 우선순위, 최종 실행시각, CPU 점유시간 등
- 메모리 관리 정보: 해당 프로세스의 주소공간 등
- 프로세스 계정 정보
- 입출력 상태 정보: 프로세스에 할당된 입출력장치 목록 등

### 스레드(Thread)란 무엇인가?

스레드는 프로세스의 실행 단위를 뜻하고, 프로세스 내의 주소공간이나 자원을 공유할 수 있다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만 프로그램 환경에 따라서 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행방식을 **멀티스레드(MultiThread)**라고 한다. 이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 가지고 있다.

## 동기와 비동기의 차이

### 동기와 비동기란?

비유적으로 설명하면 다음과 같다. 만약 해야할 일이 빨래, 설거지, 청소가 있다고 가정한다. 이 일들을 동기적으로 처리한다면 내가 정해둔 순서대로 빨래를 한다음 설거지를 하고 청소를 할 것이다. 그런데 이 일을 비동기적으로 처리한다면 빨래 업체에게 빨래를 시키고 설거지 대행 업체에 설거지를 시키고, 청소 대행 업체에 청소를 시킨다. 이 때, 어느 작업이 먼저 완료될지는 알 수 없다. 그리고 일을 맡긴 다음에는 나는 다른 업무를 수행할 수 있다. 이렇게 처리하는 것을 비동기라고 한다.

일반적으로 동기와 비동기의 차이는 메소드를 실행시킴과 동시에 반환값이 기대되는 경우에는 동기라고 표현하고, 그렇지 않은 경우에 대해서는 비동기라고 표현한다. 동시에 라는 것은 실행되었을 때 값이 반환되기 전까지, 즉 메소드가 종료되기 전까지는 blocking 되어 있다는 것을 의미한다. 비동기의 경우, blocking 되지 않고 이벤트 큐에 넣거나 백그라운드 스레드 에게 해당 작업을 위임하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.

## 프로세스 동기화
프로세스가 서로 메시지를 주고받거나 프로세스 내부에서 쓰레드끼리 자원을 공유하면서 '동기화'에 대한 문제가 항상 발생할 수 있다. 즉, 공유된 자원에 대해 프로세스, 여러 쓰레드가 동시에 접근하는 것을 '동기화'라고 하는데 이로인해 문제가 발생하게 된다. 

### Critical Section(임계 영역)
동일한 자원을 동시에 접근하는 작업(e.g. 공유하는 변수 사용, 동일 파일을 사용하는 등)을 실행하는 코드 영역을 임계 영역(Critical Section) 이라 칭한다.

### Critical Section Problem(임계 영역 문제)
프로세스들이 Critical Section을 함께 사용할 수 있는 프로토콜을 설계하는 것이다.

#### Requirements(해결을 위한 필요조건)
- Mutual Exclusion(상호 배제): 프로세스 P1이 Critical Section에서 실행중이라면, 다른 프로세스들은 그들이 가진 Critical Section에서 실행될 수 없다.
- Progress(진행): Critical Section에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 Critical Section 진입 후보로서 참여될 수 있다.
- Bounded Waiting(한정된 대기): P1이 Critical Section에 진입 신청 후부터 받아들여질 때까지, 다른 프로세스들이 Critical Section에 진입하는 횟수는 제한이 있어야 한다.

### 해결책

#### Mutex Lock
- 동시에 공유 자원에 접근하는 것을 막기위해 Critical Section에 진입하는 프로세스는 Lock을 획득하고 Critical Section을 빠져나올 때, Lock을 방출함으로써 동시에 접근이 되지 않도록 하는 방법이다.

##### 한계
- 다중처리기 환경에서는 시간적인 효율성 측면에서 적용할 수 없다.

#### Semaphores(세마포)
- 소프트웨어상에서 Critical Section 문제를 해결하기 위한 동기화 도구

##### 종류
OS는 Counting/Binary 세마포를 구분한다.

- 카운팅 세마포: 가용한 개수를 가진 자원에 대한 접근 제어용으로 사용되며, 세마포는 그 가용한 자원의 개수로 초기화된다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가한다.
- 이진 세마포: MUTEX 라고도 부르며, 상호배제의 (Mutual Exclusion)의 머릿글자를 따서 만들어졌다. 이름 그대로 0과 1사이의 값만 가능하며, 다중 프로세스들 사이의 Critical Section 문제를 해결하기 위해 사용한다.

##### DeadLock(교착 상태)
- 세마포가 Ready Queue를 가지고 있고, 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있고, Critical Section에서 실행되는 프로세스는 진입 대기중인 프로세스가 실행되야만 빠져나올 수 있는 상황을 지칭한다. 즉, 두개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 가리킨다.



## CPU Scheduling

### 스케줄링
CPU를 효율적으로 사용하기 위해서 프로세스들의 처리 순서를 배정하는 것을 의미한다. 즉, 프로세스가 작업을 수행할 때, 언제 어떤 프로세스에 CPU를 할당할지를 결정하는 작업이다. 

스케줄링 기법은 크게 두 가지로 나뉘는데, OS가 강제적으로 CPU를 사용하고 있는 프로세스를 중단시키는지 여부에 따라서 나뉜다.

#### 선점/비선점 스케줄링
- 선점(Preemptive) 스케줄링: 각각의 선점형 스케줄링의 알고리즘 기법에 따라서 해당 조건이 충족되면 현재 실행중인 프로세스의 동작이 끝나든 말든 강제적으로 실행중인 프로세스의 CPU 할당권을 뺏어와서 다음 프로세스에 할당하는 방법이다.
- 비선점(Nonpreemptive) 스케줄링: 각각의 비선점형 스케줄링 알고리즘 기법이 충족되어도 현재 실행중인 프로세스의 동작이 끝날때까지 다음 프로세스는 실행중인 프로세으의 CPU 할당권을 뺏어올수 없다는 기법이다.

### CPU 스케줄링의 종류

#### 비선점 스케줄링

- FCFS(First Come First Served)
	- Ready 큐에 도착한 순서대로 CPU를 프로세스에 할당시키는 기법
	- 실행시간이 짧은 것이 앞에 위치하면 평균 대기시간이 줄어들어서 효율성이 높아진다.

- SJF(Shortest Job First)
	- 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행한다.
	- 한 프로세스가 실행중일 때 여러개의 프로세스가 Ready 큐에 들어온다면 가장 짧은 실행시간을 가진 프로세스부터 앞으로 배치한다.
	- FCFS 스케줄링 기법보다 평균 대기시간이 줄어든다, 짧은 작업에 유리하다.
	- FCFS 스케줄링 기법에서 프로세스의 실행시간이 짧은 것부터 차례대로 들어온다면 SJF 알고리즘과 같아진다.
	- 실행시간이 무한하게 긴 프로세스가 들어오고 다른 짧은 프로세스가 계속해서 들어온다면 실행시간이 무한하게 긴 프로세스는 무한정 기다리게 되는 기아(Starvation) 현상이 발생할 수 있다.

- HRN(Highest Response-ratio Next)
	- 우선순위를 계산하여 점유 불평등을 보완한 방법이다.(SJF의 기아현상을 막기위한 방법)
	- 대기 시간과 CPU 사용시간을 고려하여 스케줄링 하는 방식이다.
	- 우선순위 = (대기시간 + 실행시간) / (실행시간)
	- 식을 봐도 알수있듯이 대기시간이 높으면 우선순위가 높은 방식임을 알 수 있다.

#### 선점 스케줄링

- 우선순위 스케줄링(Priority Scheduling)
	- 비선점 스케줄링에는 SJF라는 우선순위 스케줄링이 있다면 이와 비슷하게 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 프로세스를 처리하는 스케줄링 기법이다.
	- 우선순위가 낮은 프로세스가 무한정 기다리는 기아(Starvation)현상이 발생할 수 있다.
	- Aging 방법으로 Starvation 문제를 해결 가능하다.

> Aging 방법이란?
> 처음에 우선순위가 제일 뒤에있던 프로세스를 대기시간이 길어짐에 따라서 우선순위를 선형적으로 높여서 결국에는 기아현상을 방지하는 방법이다.

- 라운드 로빈 스케줄링(Round Robin)
	- FCFS에 의해서 프로세스들이 보내지면 각 프로세스는 동일한 시간의 CPU 할당 시간을 부여받아서 실행한다는 굉장히 공평한 알고리즘이다.
	- 할당시간이 모든 프로세스의 실행시간보다 크면 FCFS랑 똑같은 알고리즘이 된다.
	- 할당시간이 매우 작다면 문맥 교환(Context Switching)이 잦아져서 오버헤드가 증가하는 단점이 있다.

- 다단계 큐 스케줄링(Multilevel-Queue)
	-  각각의 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 방식이다.
	-  이렇게 그룹으로 분리를 해서 각각 다른 스케줄링 기법을 적용하는 알고리즘이다.
	-  빠른 시간을 요구하는 시스템 작업이나 대화형 작업을 제일 우선순위가 높은 큐에 넣고, 파일 다운로드 같은 백그라운드에서 천천히 동작해도 되는 프로세스는 우선순위가 제일 낮은 큐에 넣어서 동작하게 하는 것이다.

> 다단계 큐 스케줄링 동작원리: 우선순위가 높은 대화형 작업의 큐와 우선순위가 낮은 배치 큐가 있다고 가정한다. 이 때, 다단계 큐 스케줄링 알고리즘은 배치 큐에 있는 프로세스가 동작하려면 대화형 작업의 큐가 비어있어야 한다는 것이다. 즉, 대화형 작업의 큐가 모두 비어있어서 배치 큐의 프로세스가 실행중인데, 갑자기 대화형 작업의 큐에 프로세스가 들어오면 CPU가 선점당해서 배치 큐의 프로세스는 중단되고 대화형 작업의 프로세스가 실행되게 된다는 것이다.(Preemptive 방식의 스케줄링). 

> 또한 큐 사이에 실행시간을 라운드 로빈 방식을 이용해서 동작하게 하는 방식이 존재한다. 완전히 동일한 실행시간을 부여하는 것이 아니라 RR + Priority 방식을 택하는 방식이다. 예를 들면 foreground - background 큐 방식에서는, 빨리 처리해야 하는 큐에 대해서는 CPU 선점을 80% 할당하고 덜 중요한 큐에 대해서는 CPU 선점을 20%만 할당하는 것이다. 이렇게 되면 백그라운드 큐는 실행시간이 매우 길기 때문에 먼저 온것이 먼저 처리되는 FCFS의 성격을 띄우게 되는 것이다. 우리 컴퓨터에서는 앞의 우선순위 방식보다는 이 방식이 많이 사용되는 것을 평상시에 볼 수 있다.

-  다단계 피드백 큐 스케줄링(Multilevel-Feedback-Queue)
	- 다단계 큐 스케줄링의 단점으로 한번 큐에 들어가면 프로세스는 다른 큐로 이동하거나 변경이 불가능한 단점이 존재한다. 즉 스케줄링 오버헤드가 낮은 대신에 유연하지 못하다는 단점이 존재한다. 이러한 단점을 보완하기 위해 도입된 스케줄링 방식이다.
	- 다단계 피드백 큐 스케줄링은 프로세스의 다른 큐로의 이동이 가능하다.

> 다단계 피드백 큐 스케줄링 동작원리: 우리가 용량이 굉장히 큰 게임을 다운로드를 하려고 다운로드 버튼을 누르고 인터넷 서핑을 한다고 가정한다. 우리는 인터넷 서핑을 하기 때문에 다운로드는 백그라운드로 돌려놓는 것이 되는 것이다. 즉, 바로바로 처리해야 할 일은 인터넷 서핑을 하는 것이다. 이렇게 게임 다운로드처럼 CPU를 계속 써야하는 , CPU burst가 큰 프로세스를 우선순위가 낮다고 판단하는 것이다. 그리고 나와 상호작용할 가능성이 높은 프로세스, 입출력을 필요로 하는 이런 애들은 CPU 처리가 I/O작업이랑 번갈아가면서 일어나기 때문에 CPU burst가 작다는 점을 가지고, 이를 우선순위가 높다고 판단하는 이런 특징을 이용한 것이 다단계 피드백 큐 스캐줄링 알고리즘의 동작원리이다.

> 실행시간을 다 채운 큐는 (RR 방식을 이용하기 때문에) CPU burst 프로세스일 확률이 높다. 그래서 실행시간을 조금 늘려서 같은 큐를 실행시켜보고 또 실행시간을 다 채우면 CPU bound 프로세스일 가능성이 높다고 판단해서 문맥 전환을 하지않고 백그라운드에서 계속 프로세스를 실행시켜주는 것이다.

	다단계 피드백 큐 스케줄링의 문제점: 계속해서 대화형 프로세스와 같은 동적인 프로세스가 들어오게 되면 우선순위가 낮은 백그라운드 프로세스가 기아(Starvation)현상이 일어날 수 있다. 따라서 이와 같은 현상을 방지하지 위해서 전에 우선순위 스케줄링 문제점을 해결한 방식인 Aging 방식을 사용해서 해결할 수 있다.
